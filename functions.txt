"get-orders"
// supabase/functions/get-orders/index.ts
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};
Deno.serve(async (req)=>{
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders
    });
  }
  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(JSON.stringify({
        error: 'Unauthorized'
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? '';
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY') ?? '';
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '';
    if (!supabaseUrl || !supabaseAnonKey || !supabaseServiceKey) {
      throw new Error('Missing environment variables');
    }
    // Verificar autenticação usando anon key
    const userResponse = await fetch(`${supabaseUrl}/auth/v1/user`, {
      headers: {
        'Authorization': authHeader,
        'apikey': supabaseAnonKey
      }
    });
    if (!userResponse.ok) {
      return new Response(JSON.stringify({
        error: 'Unauthorized'
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const user = await userResponse.json();
    const { view } = await req.json();
    // Helper para fazer requests usando SERVICE ROLE (bypassa RLS)
    const supabaseFetch = async (endpoint, options = {})=>{
      const response = await fetch(`${supabaseUrl}/rest/v1/${endpoint}`, {
        ...options,
        headers: {
          'Authorization': `Bearer ${supabaseServiceKey}`,
          'apikey': supabaseServiceKey,
          'Content-Type': 'application/json',
          ...options.headers
        }
      });
      if (!response.ok) {
        const error = await response.text();
        throw new Error(`Supabase error: ${error}`);
      }
      return response.json();
    };
    // VISÃO VENDEDOR
    if (view === 'vendedor') {
      // Verificar se usuário tem lojas
      const stores = await supabaseFetch(`stores?user_id=eq.${user.id}&select=id`);
      if (!stores || stores.length === 0) {
        return new Response(JSON.stringify({
          data: [],
          message: 'User has no stores'
        }), {
          status: 200,
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          }
        });
      }
      const storeIds = stores.map((s)=>s.id).join(',');
      // Buscar order_items das lojas do vendedor
      const items = await supabaseFetch(`order_items?store_id=in.(${storeIds})&select=*,product_listings(products(images))&order=created_at.desc`);
      if (!items || items.length === 0) {
        return new Response(JSON.stringify({
          data: []
        }), {
          status: 200,
          headers: {
            ...corsHeaders,
            'Content-Type': 'application/json'
          }
        });
      }
      // Buscar orders relacionadas
      const orderIds = [
        ...new Set(items.map((item)=>item.order_id))
      ].join(',');
      const orders = await supabaseFetch(`orders?id=in.(${orderIds})&order=created_at.desc`);
      // Montar pedidos com itens (apenas os itens do vendedor)
      const pedidos = orders?.map((order)=>({
          ...order,
          order_items: items.filter((item)=>item.order_id === order.id)
        })) || [];
      return new Response(JSON.stringify({
        data: pedidos
      }), {
        status: 200,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    // VISÃO COMPRADOR (padrão)
    const orders = await supabaseFetch(`orders?user_id=eq.${user.id}&select=*,order_items(*,product_listings(products(images)))&order=created_at.desc`);
    return new Response(JSON.stringify({
      data: orders || []
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('Error:', error);
    return new Response(JSON.stringify({
      error: error.message
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
});


"get-pending-orders-count"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type'
};
Deno.serve(async (req)=>{
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders
    });
  }
  try {
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return new Response(JSON.stringify({
        error: 'Unauthorized'
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');
    // Verificar autenticação
    const userResponse = await fetch(`${supabaseUrl}/auth/v1/user`, {
      headers: {
        'Authorization': authHeader,
        'apikey': supabaseAnonKey
      }
    });
    if (!userResponse.ok) {
      return new Response(JSON.stringify({
        error: 'Unauthorized'
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const user = await userResponse.json();
    // Buscar lojas do usuário usando SERVICE ROLE
    const storesResponse = await fetch(`${supabaseUrl}/rest/v1/stores?user_id=eq.${user.id}&select=id`, {
      headers: {
        'Authorization': `Bearer ${supabaseServiceKey}`,
        'apikey': supabaseServiceKey,
        'Content-Type': 'application/json'
      }
    });
    if (!storesResponse.ok) {
      throw new Error('Failed to fetch stores');
    }
    const stores = await storesResponse.json();
    if (!stores || stores.length === 0) {
      return new Response(JSON.stringify({
        count: 0
      }), {
        status: 200,
        headers: {
          ...corsHeaders,
          'Content-Type': 'application/json'
        }
      });
    }
    const storeIds = stores.map((s)=>s.id).join(',');
    // Buscar itens pendentes usando SERVICE ROLE
    const itemsResponse = await fetch(`${supabaseUrl}/rest/v1/order_items?store_id=in.(${storeIds})&status=eq.pendente&select=order_id`, {
      headers: {
        'Authorization': `Bearer ${supabaseServiceKey}`,
        'apikey': supabaseServiceKey,
        'Content-Type': 'application/json'
      }
    });
    if (!itemsResponse.ok) {
      throw new Error('Failed to fetch items');
    }
    const items = await itemsResponse.json();
    // Contar orders únicas
    const uniqueOrders = [
      ...new Set(items.map((item)=>item.order_id))
    ];
    return new Response(JSON.stringify({
      count: uniqueOrders.length
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('Error:', error);
    return new Response(JSON.stringify({
      error: error.message
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      }
    });
  }
});
